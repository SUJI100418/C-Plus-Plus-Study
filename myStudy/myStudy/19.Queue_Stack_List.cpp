/*

## 큐 FIFO : Fist In First Out
- 서버 대기열 : 웹 페이지 요청, 큐에 웹 리퀘스트 하나씩 쌓고, 하나씩 꺼내서 처리
- queue<string> q;
- q.push("aa");
- q.front(); q.back();

## 스택 LIFO : Last In First Out
- 스택 메모리랑 작동 방법이 똑같다.
- stack<string> s;
- s.top(), s.puth(), s.pop() -> pop시 요소 반환x, 그냥 삭제함

## 리스트 : 좋은 면접 문제 C로 만들어라
- 양방향 연결 리스트
- 양쪽 끝에서 삽입/제거 가능
- insert(1, value), push_front, push_back

리스트 장점 : 탐색 안하고 위치 안다면 삽입, 제거 걸리는 시간 O(1), 어느 위치든 삽입/제거 가능
리스트 단점 : 탐색 느리다, 메모리가 불연속적이고(CPU 메모리 캐쉬, 연속적이어야 빠르다의 개념과 반대, 벡터와 맵이 더 빠름) 임의적으로 접근 불가능하다.

----------------------

STL 컨테이너, 벡터(자동 메모리 조절 배열)와 맵(키,벨류)이 빨라서 중요

-> 결국 STL 목적? 
메모리가 자동으로 관리되는 템플릿 기반의 표준 인터페이스

Q. 모든 컨테이너에 알맞는 표준 인터페이스는 항상 옳은가?
-> vector.push_back()은 스택처럼 보인다. 그냥 컨테이너마다 특징적인 함수를 만드는게 좋을지도?

Q. 메모리 알아서 관리해주는게 정말 좋은가? 
-> 빈번한 재할당으로 메모리 단편화 문제가 있다. 

-----------------------



*/