/*

## Smart Pointer : C++ 이후, 메모리 해제 까먹음 -> 알아서 해제 = delete 호출 할 필요 없음. = 가비지 콜렉션보다 빠르다.
	
	1. unique_ptr : RAII 원칙
	2. shared_ptr :
	3. weak_ptr : 
	

----------------------------

### unique_ptr = 넌 소유자가 하나 밖에 없는 놈이다.

	- 원시 포인터를 단독으로 소유
	- 복사나 대입 불가
	- 범위를 벗어나면, 원시 포인터는 지워짐
	
	1. 클래스 생성자/소멸자 적합 : 소멸자에 delete 없음
	2. 지역 변수 : 스택에 엄청 큰 오브젝트 못 넣을 때, 힙에 생성
	3. STL 벡터에 포인터 저장

	-> 결국, new 쓸 때 unique_ptr 써라.

	- unique_ptr up = make_unique<자료형>();

	Q. 유니트 포인터 복사할 수 있나요? 
	-> 아니요. 대신 소유권은 넘겨줄 수 있습니다.

	unique_ptr<Vector> vector = make_unique<Vector>(1.0f, 3.0f);
	unique_ptr<Vector> another(move(vector));


----------------------------

### shared_ptr : 남과 소유권을 공유하는 포인터, 참조 카운팅, 자동 메모리 관리

	- 자동 메모리 관리? 
		1. 가비지 컬렉션 : C#, Java
			- 매 주기마다, 루트(전역 변수, 스택, 레지스터)에서 힙에 있는 개체를 접근 가능한지 체크
			- 접근할 수 없다면, 쓰레기로 판단
			- 가비지 컬렉션의 최적화? 계절별 가비지 컬렉션

		2. 참조 카운팅 : 실시간 애플리케이션, 개체에 대한 참조가 없을 때-> 개체를 해제
			- 참조 횟수를 활용
			- int mRefCount; char* mString;
			- 문제점, 참조 횟수가 너무 많이 바뀌고 순환 참조(A->B, B->A) 발생 가능성

	- 두 개의 포인터를 소유한다. 
		- 원시 포인터(데이터) 가리키는 포인터
		- 제어 블록을 가리키는 포인터


----------------------------

### weak_ptr : 참조 카운팅에서 순환 포인터 문제 해결

	- 원시 참조는 원시 포인터 해제에 영향을 끼치지 않는다.
	- 약한 참조로 참조되는 개체는 강한 참조 카운트가 0이 될 때 소멸된다.


----------------------------

### lvalue vs rvalue

	- lvalue : 임시적이지 않은 것, 항상 우리가 쓰고 있던 것
	- rvalue : 임시적인 값, 한번 쓰고 버렸던 것 들. 유니크 포인터 지원해주기 위해 들어옴, move()


----------------------------

### constexpr : 프로그래머의 의도를 보여주는 방법, 컴파일 중에 판단

### 람다 식 : 이름 없는 한 줄짜리 함수

### 가변 인자 템플릿 : 템플릿에 아무거나 매개 변수 받는 것


----------------------------
*/